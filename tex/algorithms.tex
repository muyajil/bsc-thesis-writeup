\section{Algorithms}

\subsection{Query Containment}

The subject of query containment refers to the problem where for two queries $Q_1$ and $Q_2$ we want to answer if $Q_1$ is contained in $Q_2$ in all indistinguishable database states.
%
\remark{introduce indistinguishability of database states}
%
\remark{maybe reference to book for NP hardness.}

\remark{State the problem clearly. Give decidability results. Discuss its use in databases.}

\remark{
The problem is undecidable for Relational Calculus and SQL.
%
It is NP-hard only for conjunctive queries.
} 

\subsection{Query Containment Approximation}

\remark{There is no intuition whatsoever on why we need query containment for checking security.
%
In the paper, we defined an algorithm for checking containment and we use it as a key component of the security check.
%
The algorithm is formalized using inference rules and it is an under-approximation.
%
The algorithm is only for relational calculus.
%
Here, we extend it to SQL.
}

Since the decision of query containment is \emph{NP-hard}, i.e., not decidable in polynomial time \remark{only if $P \neq NP$}, \remark{Undecidable!!}  Guarnieri et al. have developed a rule set that under-approximates query containment.
%
The rules were developed for the relational algebra, which as mentioned before differs from SQL. 
%
Here we extend these rules to SQL.
%
In the following we present this extended rule set. 
%
Let $T_i$ denote tables, $A_i$ sets of attributes within tables, $Q_i$ \texttt{SELECT} queries of the form \texttt{SELECT $A$ FROM $T$ WHERE $\phi$}, and greek letters stand for boolean expressions on the tuples contained in the tables.
%
The inference rules consist of tuples $(u,Q)$ where $u$ is the user issuing the query $Q$.
%
All the following rules are only applicable if the user $u$ is allowed to read all tables or views referenced in the premiss.

\[
\infer[\text{ID}]
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi$}})}
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi$}})}
\]

Any \texttt{SELECT} query is contained in itself.

\[
\infer[\text{AND}]
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi$}})}
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi \land \psi$}})}
\]

The rule holds since we weaken the condition by reducing the number of boolean expressions in the conjunction. Therefore the tuples resulting from the query in the premiss are contained in the tuples resulting from the query in the conclusion.

\[
\infer[\text{OR1}]
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi \lor \psi$}})}
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi$}})}
\]

\[
\infer[\text{OR1}]
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi \lor \psi$}})}
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\psi$}})}
\]

This rule holds since we again weaken the condition again by adding a disjunction.

\[
\infer[\text{PROJ1}]
	{(u,\text{\texttt{SELECT $A_2$ FROM $T_1$ WHERE $\phi$}})}
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi$}} \qquad A_1 \subseteq A_2)}
\]

In this rule the tuples resulting from both queries are the same since the condition in the \texttt{WHERE} clause is the same for both queries. The data however from the query in the premiss is contained in the data from the conclusion.

\[
\infer[\text{PROJ2}]
	{(u,\text{\texttt{SELECT $A_2$ FROM $T_2$ WHERE $\phi$}})}
	{(u,\text{\texttt{SELECT $A_1$ FROM $T_1$ WHERE $\phi$}} \qquad A_1 \subseteq A_2 \qquad T_1 \subseteq T_2)}
\]

Here the same argumentation holds as above. Addionally we have that the table we are querying from in the premiss is contained in the respective table in the conclusion. Therefore it is obvious that all data returned from querying $T_1$ is contained in the data returned from $T_2$.

\[
\infer[\text{INTER1}]
	{(u,Q_1)}
	{(u,Q_1 \text{\texttt{ INTERSECTION }} Q_2)}
\]

\[
\infer[\text{INTER2}]
	{(u,Q_2)}
	{(u,Q_1 \text{\texttt{ INTERSECTION }} Q_2)}
\]

By the definition of intersecting two sets these rules hold trivially.

\[
\infer[\text{UNION1}]
	{(u,Q_1 \text{\texttt{ UNION }} Q_2)}
	{(u,Q_1)}
\]

\[
\infer[\text{UNION2}]
	{(u,Q_1 \text{\texttt{ UNION }} Q_2)}
	{(u,Q_2)}
\]

By the definition of unifying two sets these rules hold trivially.

\[
\infer[\text{EXCEPT}]
	{(u,Q_1)}
	{(u,Q_1 \text{\texttt{ EXCEPT }} Q_2)}
\]

This rule holds by the definition of subtracting sets.

\subsection{Rewriting of \texttt{SELECT} queries}

In the new algorithm one component of authorizing \texttt{SELECT} queries is the rewriting of those.
%
The rewriting produces a new query, where the resulting set is the set of tuples equal to subtracting an under-approximation of the query from an over-approximation of the query.
%
Both the under- and the over-approximation are secure queries for the user, since they only reference tables, which the user is authorized to read.
%
The approximations are computed based on the inference rules introduced above.
%
We define the function $\operatorname{rewrite}(Q)$, where $Q$ is a \texttt{SELECT} query of the form \texttt{SELECT $A$ FROM $T$ WHERE $\phi$}.
%
Further we define two functions $\operatorname{under}(Q)$ and $\operatorname{over}(Q)$,  where $Q$ is passed from $\operatorname{rewrite}$.
%
These two functions return a query that is an over- respectively under-approximation.

\smallskip
\noindent
{$\mathbf{ \mathrm{\bf over}(Q)}$:}
%
In this function we first build an inference forest that includes all possible inference trees from the rules introduced above.
%
As an example recall the database setup from the motivating example:
\\
Consider a database with tables \texttt{Programmers}, \texttt{Clerks}, and \texttt{HR}, containing the information of employees of the respective departements.
%
Further the database contains the following views:
\begin{itemize}
	\item \texttt{OldProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age > 40}
	\item \texttt{YoungProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age <= 40}
	\item \texttt{ProgrammerOrClerk} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM Clerks)}
	\item \texttt{ProgrammerOrHR} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM HR)}
\end{itemize}
%
Assume that there is a database user $u$ which has read access to all views, but does not have read access to the tables.
%
The user $u$ wants to find out who is employed as a Programmer and issues the following query $Q := $ \texttt{SELECT * FROM Programmers}. 
%
Below see the inference forest produced by $\operatorname{over}(Q)$

\[
\infer[\text{INTER1}]
	{\text{\texttt{ SELECT * FROM Programmers}}}
	{
		\infer[ID]
		{\text{\texttt{ (SELECT * FROM Programmers) UNION (SELECT * FROM Clerks)}}}
		{\text{\texttt{ SELECT * FROM ProgrammerOrClerk}}}
	}
\]

\[
\infer[\text{INTER2}]
	{\text{\texttt{ SELECT * FROM Programmers}}}
	{
		\infer[ID]
		{\text{\texttt{ (SELECT * FROM Programmers) UNION (SELECT * FROM HR)}}}
		{\text{\texttt{ SELECT * FROM ProgrammerOrHR}}}
	}	
\]

After that $\operatorname{over}(Q)$ produces a new query $Q^\bot$, which is the intersection of all leaves of the inference forest: 
%
The query $Q^\bot$ is then returned to rewrite.

\smallskip
\noindent
{$\mathbf{ \mathrm{\bf under}(Q)}$:}
The function $\operatorname{under}(Q)$ is implemented analogously, and returns the query $Q^\top$, which is the \texttt{UNION} of all leaves in the inference forest. Below see the inference forest produced by $\operatorname{under}(Q)$:

\[
\infer[\text{AND}]
	{\text{\texttt{ SELECT * FROM Programmers}}}
	{
		\infer[ID]
		{\text{\texttt{ SELECT * FROM Programmers WHERE Age > 40}}}
		{\text{\texttt{ SELECT * FROM OldProgrammers}}}
	}	
\]

\[
\infer[\text{AND}]
	{\text{\texttt{ SELECT * FROM Programmers}}}
	{
		\infer[ID]
		{\text{\texttt{ SELECT * FROM Programmers WHERE Age <= 40}}}
		{\text{\texttt{ SELECT * FROM YoungProgrammers}}}
	}
\]
\noindent
It is possible to have a better under-approximation by applying the rules PROJ1 and PROJ2. In this example however the above forest is a good enough approximation.

After that the function $\operatorname{rewrite}(Q)$ returns the query \texttt{$Q^\bot$ EXCEPT $Q^\top$}.

\subsection{Authorization of \texttt{SELECT} queries}

In the example previously introduced a motivating example , we showed that the current access control mechanism implemented in PostgreSQL too restrictive to be used, in practice, with powerful access control mechanisms such as the one in the paper.
%
Here, we develop a new mechanism, which relies on query containment and the rewriting function introduced above.
%
For each query $Q$ we will execute the function $\operatorname{rewrite}(Q)$.
%
The returned query will then be executed.
%
$Q$ will be authorized if the result is \texttt{NULL}.

\smallskip
\noindent
{\bf Example:}
From the example above $\operatorname{rewrite}(Q)$ will return the following query:
\begin{verbatim}
((SELECT * FROM ProgrammerOrHR) INTERSECTION
 (SELECT * FROM ProgrammerOrClerk))
 EXCEPT
((SELECT * FROM YoungProgrammer) UNION
 (SELECT * FROM OldProgrammer))
\end{verbatim}
\noindent
It is obvous that the query will return \texttt{NULL}, therefore the algorithm will authorize the query $Q = $ \texttt{SELECT * FROM Programmer} $\blacksquare$.