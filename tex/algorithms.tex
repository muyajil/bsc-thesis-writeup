\section{Algorithms}

\remark{Here you should give some intuition why we're dealing with query containment for security}

\subsection{Query Containment}

\remark{Here, First give the intuition, then formalize the problem, then give results.}

The subject of query containment refers to the problem where for two queries $Q_1$ and $Q_2$ we want to answer if the tuples returned from $Q_1$ are always, i.e., in all database states, contained in the ones returned from $Q_2$.
%
This problem is well-known to be undecidable for relational calculus and SQL.~\cite{abiteboul1995foundations}.
%
\remark{Discuss its use in databases.}

\subsubsection{Query Containment Approximation}

As shown in Chapter 3, query containment is a key part in access control algorithms such as the one proposed in~\cite{guarnieri2016strong}.
Since query containment is undecidable, in general, Guarnieri et al. have developed a set of inference rules to compute sound under-approximations of query containment for relational calculus queries.
%
Here, we extend them to the SQL language.
%
Figure~\ref{figure:algorithms:grammar} describes the subset of SQL we focus on. 
%
In the following, let $T_i$ denote sequences of tables, $A_i$ denote sequences of attributes within tables, greek letters denote for boolean expressions, and $Q_i$ denote \texttt{SELECT} queries.


\begin{figure}[!ht]

\begin{tabular}{c c l}
$a$ & $:=$ & Attribute identifier \\
    & & \\
$t$ & $:=$ & Relation identifier $|$ View identifier \\ \\

$A$ & $:=$ & $a^*$ \\
    & & \\
$T$ & $:=$ &  $t^*$ \\
    & & \\
$\phi$ & $:=$ & Boolean SQL expression  \\
    & & \\
$Q$ & $:=$ & \texttt{SELECT $A$ FROM $T$ WHERE $\phi$} \\
    & $|$  & $Q$ \texttt{UNION} $Q$ \\
    & $|$  & $Q$ \texttt{INTERSECTION} $Q$ \\
    & $|$  & $Q$ \texttt{EXCEPT} $Q$ \\

\end{tabular}
\remark{I've modified a bit the grammar. Checks whether it makes sense.}
\caption{Grammar of \texttt{SELECT} queries}
\label{figure:algorithms:grammar}
\end{figure}
%
Furthermore, let $w(Q)$ be the function returning the \texttt{WHERE} clause of the \texttt{SELECT} query $Q$, and $\operatorname{freeV}(Q)$ be the fucntion returning the set containing all free variables in the \texttt{SELECT} query $Q$. \remark{? there are no free variables in SQL queries, in general.}
%
Figure~\ref{figure:algorithms:infrules} shows our inference rules.
%
\begin{figure}[!ht]
\[
\infer[\text{ID}]
	{Q_1 \subseteq Q_1}
	{}
\qquad	
\infer[\text{AND}]
	{Q_1 \subseteq Q_2}
	{w(Q_2) = w(Q_1) \land \phi}
\qquad
\infer[\text{OR}]
	{Q_1 \subseteq Q_2}
	{w(Q_1) = w(Q_2) \lor \phi}
\]


\begin{multline*}
\infer[\text{PROJ1}]
	{\texttt{SELECT}\ A_1\ \texttt{FROM}\ T_1\ \texttt{WHERE}\ \phi_1 \subseteq \texttt{SELECT}\ A_2\ \texttt{FROM}\ T_2\ \texttt{WHERE}\ \phi_2}
	{
	\texttt{SELECT}\ A_1'\ \texttt{FROM}\ T_1\ \texttt{WHERE}\ \phi_1 \subseteq \texttt{SELECT}\ A_2'\ \texttt{FROM}\ T_2\ \texttt{WHERE}\ \phi_2 \\
	\hfill A_1' = a_1^1, \ldots, a_n^2 \hfill \qquad
	\hfill A_2' = a_1^2, \ldots, a_n^2 \hfill \qquad
	\hfill 1 \leq j \leq n \hfill \\
	\hfill A_1 = a_1^1, \ldots, a_{j-1}^1, a_{j+1}^1, \ldots,  a_n^1 \hfill \qquad
	\hfill A_2 = a_1^2, \ldots, a_{j-1}^2, a_{j+1}^2, \ldots, a_n^2 \hfill 	
	}
\end{multline*}

\[
\infer[\text{PROJ2}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad T_1 \setminus T_1' = T_2 \setminus T_2'\qquad 
		\lbrace	T_1, T_1', T_2, T_2' \rbrace \subseteq \operatorname{freeV}(Q_1) \cup \operatorname{freeV}(Q_2)}
\]
\remark{Are you sure that this rule is sound?? It looks a bit weird to me. If you're sure it's sound, then rewrite it as I've fixed rule PROJ1. (By the way, removing tables from the FROM clause is not called projection in general.)}





\[
\infer[\text{INTER1}]
	{Q_1 \text{\texttt{ INTERSECTION }} Q_3 \subseteq Q_1}
	{}
\qquad
\infer[\text{INTER2}]
	{Q_3 \text{\texttt{ INTERSECTION }} Q_1 \subseteq Q_1}
	{}
\]

\[
\infer[\text{UNION1}]
	{Q_1 \subseteq Q_1 \text{\texttt{ UNION }} Q_3}
	{}
\qquad
\infer[\text{UNION2}]
	{Q_1 \subseteq Q_3 \text{\texttt{ UNION }} Q_1}
	{}
\]

\[
\infer[\text{EXCEPT}]
	{Q_1 \text{\texttt{ EXCEPT }} Q_3 \subseteq Q_1}
	{}
\qquad
\infer[\text{TRANS}]
	{Q_1 \subseteq Q_3}
	{Q_1 \subseteq Q_2 \qquad Q_2 \subseteq Q_3}
\]
\caption{Inference Rules for query containment}
\label{figure:algorithms:infrules}
\end{figure}

\remark{Explain each ``family'' of rules. Give some intuition, and explain why they are sound.
%
I'd avoid saying ``holds trivially'' too much, as it downplays your contribution.}

The ID-rule holds trivially.
%
In the AND-rule we restrict the resulting bag further by adding a boolean expression in conjunction. 
%
Therefore the rule holds.
%
The OR-rule holds by the same argumentation, namely we extend the resulting bag, by adding a boolean expression in disjunction,  which increases the number of tuples satisfying the \texttt{WHERE} clause. \remark{This part is unclear.}
%
The PROJ1-rule is valid since we project out the same set of attributes. Therefore the actual rows returned from the table are the same, with less attributes.
%
\remark{I am not perfectly sure about the PROJ rules. This is the intuition, but make it clearer.}
%
The PROJ2-rule holds since we reduce the multiset of tuples from which we select by the same tuples in both queries.
%
By combining PROJ1 and PROJ2 we get the rule PROJ3.
%
The rules INTER1 and INTER2 hold trivially, by the definition of intersecting two multisets.
%
The same argumentation holds for the rules UNION1 and UNION2, which rely on the definition of unifying multisets.
%
The rule EXCEPT holds by the definition of subtracting multisets.
%
Lastly the rule TRANS holds by the definition of containment.

\FloatBarrier
\subsection{Checking security of \texttt{SELECT} queries}

As seen in Chapter 2 \texttt{SELECT} queries are trivially authorized \remark{authorized by the SQL query?} if the user that issues the query has read privileges on all the referenced tables.
%
However this mechanism is too restrictive for implementing a powerful mechanism such as the one presented in~\cite{guarnieri2016strong}.
%
The authors of~\cite{guarnieri2016strong} have developed an algorithm that checks the security of queries, which relies on query containment and query rewriting. 
%
For each query $Q$ the rewriting algorithm produces a secure over-approximation $Q^\bot$ and under-approximation $Q^\top$ with respect to query containment, using the rule set introduced above. \remark{This part is unclear. The under and over-approximations are not computed using the rules.}
%
\remark{This part is unclear. Why don't you just say something like ``For each table or view $O$, we denote by $O^\top$ (respectively $O^\bot$) the set ... . This set is computed using the query containment rules introduced in Section XX''} 
%
The extended rule set is used to create two mappings within the database.
%
We map all tables or views $T$ to the set $T^\bot$, which contains all tables or views that contain $T$ based on the above inference rules.
%
In the same way we map each table or view $T$ to the set $T^\top$, which contain all tables or views that are contained by $T$.
%
Here we use these mappings to provide the same rewriting as in~\cite{guarnieri2016strong}, but for SQL.

\subsubsection{Rewriting Algorithm}
%
Our rewriting algorithm is shown in Algorithm~\ref{alg:algorithms:rewrite}. % shows a pseudo code of the implementation.
%
The algorithm returns the two queries $Q^\bot$ and $Q^\top$.
%
The query $Q^\bot$ is built by replacing each referenced table $T$ by the intersection of all the tables $\tau \in T^\bot$ that the user is authorized to read.
%
$Q^\top$ is built analogously with unions of all the tables $\tau \in T^\top$.
%
We further define the helper function \emph{$S$.hasNext()}, which returns false if the table $\tau$ is the last one in the set $S$ and true otherwise. \remark{hasNext does not make any sense for a set (no order)}



\remark{Explain this part a bit more.}
%
Therefore it is trivial that both queries $Q^\bot$ and $Q^\top$ are secure, since all the tables referenced within are readable to the user issuing the query.
%
Using the inference rules we can further show that for any query $Q$ it holds that $Q^\top \subseteq Q \subseteq Q^\bot$.
%
\remark{I'm pretty sure you cannot prove this using our rules.}

%
\begin{algorithm}
\caption{Rewriting Algorithm for SQL queries}
\label{alg:algorithms:rewrite}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{Rewritten queries $Q^\top$, $Q^\bot$}
	$Q^\bot$ = $Q$\;
	$Q^\top$ = $Q$\;
	\ForEach{table $T$ referenced in $Q$}{
		$T'$ = "("\;
		$T''$ = "("\;
		\ForEach{table $\tau$ in $T^\bot$}{
			\If{$u$ is authorized to read $\tau$}
				{\eIf{$T^\bot$.hasNext()}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$) INTERSECTION}"\;}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
     	
		\ForEach{table $\tau$ in $T^\top$}{
			\If{$u$ is authorized to read $\tau$}
				{\eIf{$T^\top$.hasNext()}
					{$T''$ += "\texttt{(SELECT * FROM $\tau$) UNION}"\;}
					{$T''$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
		$T'$ += "\texttt{) AS $T$}"\;
		$T''$ += "\texttt{) AS $T$}"\;
		Replace $T$ with $T'$ in $Q^\bot$\;
     	Replace $T$ with $T''$ in $Q^\top$\;
     }

     \Return ($Q^\bot$, $Q^\top$)\;
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
Recall the example given in Chapter 2:
\\
Consider a database with tables \texttt{Programmers}, \texttt{Clerks}, and \texttt{HR}, containing the information of employees of the respective departments.
%
Further the database contains the following views:
\begin{itemize}
	\item \texttt{OldProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age > 40}
	\item \texttt{YoungProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age <= 40}
	\item \texttt{ProgrammerOrClerk} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM Clerks)}
	\item \texttt{ProgrammerOrHR} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM HR)}
\end{itemize}
%
Assume that there is a database user $u$ which has read access to all views, but does not have read access to the tables.
%
The user $u$ wants to find out who is employed as a Programmer and issues the following query $Q := $ \texttt{SELECT * FROM Programmers}.
%
The mappings that are computed for the table \texttt{Programmers} before the rewriting algorithm look as follows:
\begin{itemize}
	\item $T^\bot = \lbrace \text{\texttt{ProgrammerOrClerk}, \texttt{ProgrammerOrHR}} \rbrace$
	\item $T^\top = \lbrace \text{\texttt{YoungProgrammers}, \texttt{OldProgrammers}} \rbrace$
\end{itemize}
%
Therefore the rewriting algorithm will return the following queries:
\begin{itemize}
	\item $Q^\bot$ = \texttt{SELECT * FROM ((SELECT * FROM ProgrammerOrClerk) INTERSECTION (SELECT * FROM ProgrammerOrHR)) AS Programmer}
	\item $Q^\top$ = \texttt{SELECT * FROM ((SELECT * FROM YoungProgrammers) UNION (SELECT * FROM OldProgrammers)) AS Programmer}
\end{itemize}

\subsubsection{Authorization of \texttt{SELECT} queries}

As we have seen before the both the over- and under-approximation are secure according to the current SQL standard, since all the referenced tables in those queries are readable to the user issuing the query.
%
We have further seen that the inclusions $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$ hold for the rewritten queries $Q^\top$ and $Q^\bot$.
%
The authorization algorithm for \texttt{SELECT} queries is shown in figure~\ref{alg:algorithms:auth}
%
For each \texttt{SELECT} query $Q$ the algorithm uses the rewrite function introduced above to obtain the approximations $Q^\bot$ and $Q^\top$.
%
After that the algorithm checks if the tuples returned by $Q^\bot$ and $Q^\top$ are the same, by executing the query  $Q^\bot$ \texttt{EXCEPT} $Q^\top$ and checking if it returns $\emptyset$.
%
If this is the case, we know that $Q^\bot \subseteq Q^\top$.
%
Further we know that $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$, which leads to the conclusion that $Q^\top = Q = Q^\bot$.
%
Since both $Q^\bot$ and $Q^\top$ are secure, we can argue that $Q$ is secure as well and authorize it.
%
\begin{algorithm}
\caption{Authorization algorithm for \texttt{SELECT} queries}
\label{alg:algorithms:auth}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{$\top$ or $\bot$}
	($Q^\bot$, $Q^\top$) = rewrite($Q$)\;
	$Q'$ = $Q^\bot$ + "\texttt{EXCEPT}" + $Q^\top$\;
	$R$ = executeQuery($Q'$)\;
	\eIf{$R$ == $\emptyset$}
		{\Return $\top$ \;}
		{\Return $\bot$ \;}
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
From the example above the authorization algorithm will execute the following query:
\begin{verbatim}
((SELECT * FROM ProgrammerOrHR) INTERSECTION
 (SELECT * FROM ProgrammerOrClerk))
 EXCEPT
((SELECT * FROM YoungProgrammer) UNION
 (SELECT * FROM OldProgrammer))
\end{verbatim}
\noindent
It is obvous that the query will return $\emptyset$, therefore the algorithm will authorize the query $Q = $ \texttt{SELECT * FROM Programmer} $\blacksquare$.