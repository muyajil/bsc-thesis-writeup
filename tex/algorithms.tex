\section{Algorithms}

\subsection{Query Containment}

The subject of query containment refers to the problem where for two queries $Q_1$ and $Q_2$ we want to answer if the tuples returned from $Q_1$ are always, i.e., in all database states, contained in the ones returned from $Q_2$.
%
This problem is well-known to be undecidable for Relational Calculus and SQL.~\cite{abiteboul1995foundations}.
%
\remark{Discuss its use in databases.}

\subsubsection{Query Containment Approximation}

Since the decision of query containment is undecidable Guarnieri et al. have developed a rule set that produces sound under-approximations of query containment.
%
The rules were developed for the Relational calculus, which as mentioned before differs from SQL. 
%
Here we extend these rules to SQL.
%
Let $T_i$ denote sets of tables, $A_i$ sets of attributes within tables, $Q_i$ \texttt{SELECT} queries of the form \texttt{SELECT $A_i$ FROM $T_i$ WHERE $\phi$}, and greek letters stand for boolean expressions.
%
Figure~\ref{figure:algorithms:infrules} shows the extended rules.

\begin{figure}[!ht]
\[
\infer[\text{ID}]
	{Q_1 \subseteq Q_1}
	{}
\qquad	
\infer[\text{AND}]
	{Q_1 \land \psi \subseteq Q_1}
	{}
\qquad
\infer[\text{OR}]
	{Q_1 \subseteq Q_1 \lor \psi}
	{}
\]

\[
\infer[\text{PROJ1}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad A_1 \setminus A_1' = A_2 \setminus A_2'}
\qquad
\infer[\text{PROJ2}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad T_1 \setminus T_1' = T_2 \setminus T_2'}
\]

\[
\infer[\text{PROJ3}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad A_1 \setminus A_1' = A_2 \setminus A_2' \qquad T_1 \setminus T_1' = T_2 \setminus T_2'}
\]

\[
\infer[\text{INTER1}]
	{Q_2 \subseteq Q_1}
	{Q_2 \equiv Q_1 \text{\texttt{ INTERSECTION }} Q_3}
\qquad
\infer[\text{INTER2}]
	{Q_2 \subseteq Q_1}
	{Q_2 \equiv Q_3 \text{\texttt{ INTERSECTION }} Q_1}
\]

\[
\infer[\text{UNION1}]
	{Q_1 \subseteq Q_2}
	{Q_2 \equiv Q_1 \text{\texttt{ UNION }} Q_3}
\qquad
\infer[\text{UNION2}]
	{Q_1 \subseteq Q_2}
	{Q_2 \equiv Q_3 \text{\texttt{ UNION }} Q_1}
\]

\[
\infer[\text{EXCEPT}]
	{Q_2 \subseteq Q_1}
	{Q_2 \equiv Q_1 \text{\texttt{ EXCEPT }} Q_3}
\qquad
\infer[\text{TRANS}]
	{Q_1 \subseteq Q_3}
	{Q_1 \subseteq Q_2 \qquad Q_2 \subseteq Q_3}
\]
\caption{Inference Rules for query containment}
\label{figure:algorithms:infrules}
\end{figure}

The ID-rule holds trivially.
%
In the AND-rule we restrict the resulting bag further by adding a boolean expression in conjuction. 
%
Therefore the rule holds.
%
The OR-rule holds by the same argumentation, namely we extend the resulting bag, by adding a boolean expression in disjunction, wich increases the number of tuples satisfying the \texttt{WHERE} clause.
%
The PROJ1-rule is valid since we project out the same set of attributes. Therefore the actual rows returned from the table are the same, with less attributes.
%
\remark{I am not perfectly sure about the PROJ rules}
%
The PROJ2-rule holds since we reduce the multiset of tuples from which we select by the same tuples in both queries.
%
By combining PROJ1 and PROJ2 we get the rule PROJ3.
%
The rules INTER1 and INTER2 hold trivially, by the definition of intersecting two multisets.
%
The same argumentation holds for the rules UNION1 and UNION2, which rely on the definition of unifying multisets.
%
The rule EXCEPT holds by the definition of subtracting multisets.
%
Lastly the rule TRANS holds by the definition of containment.

\FloatBarrier
\subsection{Checking security of \texttt{SELECT} queries}

As seen in Chapter 2 \texttt{SELECT} queries are trivially authorized if the user that issues the query has read privileges on all the referenced tables.
%
However this mechanism is too restrictive for implementing a powerful mechanism such as the one presented in~\cite{guarnieri2016strong}.
%
The authors of~\cite{guarnieri2016strong} have devised a algorithm that checks the security of queries, which relies on query containment and the rewriting of the query.
%
For each query $Q$ the rewriting algorithm produces a secure over-approximation $Q^\bot$ and under-approximation $Q^\top$ with respect to query containment, using the rule set introduced above.
%
The extended rule set is used to create two mappings within the database.
%
We map all tables or view $T$ to the set $T^\bot$, which contains all tables or views that contain $T$ based on the above inference rules.
%
In the same way we map each table or view $T$ to the set $T^\top$, which contain all tables or views that are contained by $T$.
%
Here we use these mappings to provide the same rewriting as in~\cite{guarnieri2016strong}, but for SQL.

\subsubsection{Rewriting Algorithm}
%
Algorithm~\ref{alg:algorithms:rewrite} shows an pseudo code of the implementation.
%
The rewriting algorithm returns the two queries $Q^\bot$ and $Q^\top$.
%
The query $Q^\bot$ is built by replacing each referenced table $T$ by the intersection of all the tables $\tau \in T^\bot$ that the user is authorized to read.
%
$Q^\top$ is built analogously with unions of all the tables $\tau \in T^\top$.
%
We further define the helper function \emph{$S$.hasNext()}, which returns true if the table $\tau$ is the last one in the set $S$ and false otherwise.
%
Therefore it is trivial that both queries $Q^\bot$ and $Q^\top$ are secure, since all the tables referenced within are readable to the user issuing the query.
%
Using the inference rules we can further show that for any query $Q$ it holds that $Q^\top \subseteq Q \subseteq Q^\bot$.
%
\begin{algorithm}
\caption{Rewriting Algorithm for SQL queries}
\label{alg:algorithms:rewrite}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{Rewritten queries $Q^\top$, $Q^\bot$}
	$Q^\bot$ = $Q$\;
	\ForEach{table $T$ referenced in $Q^\bot$}{
		$T'$ = "("\;
		\ForEach{table $\tau$ in $T^\bot$}{
			\If{$u$ is authorized to read $\tau$}
				{\eIf{$T^\bot$.hasNext()}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$) INTERSECTION}"\;}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
		$T'$ += "\texttt{) AS $T$}"\;
     	Replace $T$ with $T'$ in $Q^\bot$\;
     }
    
    $Q^\top$ = $Q$\;
	\ForEach{table $T$ referenced in $Q^\top$}{
		$T'$ = "("\;
		\ForEach{table $\tau$ in $T^\top$}{
			\If{$u$ is authorized to read $\tau$}
				{\eIf{$T^\top$.hasNext()}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$) UNION}"\;}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
		$T'$ += "\texttt{) AS $T$}"\;
     	Replace $T$ with $T'$ in $Q^\top$\;
     }
     \Return ($Q^\bot$, $Q^\top$)\;
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
Recall the database setup from Chapter 2:
\\
Consider a database with tables \texttt{Programmers}, \texttt{Clerks}, and \texttt{HR}, containing the information of employees of the respective departements.
%
Further the database contains the following views:
\begin{itemize}
	\item \texttt{OldProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age > 40}
	\item \texttt{YoungProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age <= 40}
	\item \texttt{ProgrammerOrClerk} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM Clerks)}
	\item \texttt{ProgrammerOrHR} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM HR)}
\end{itemize}
%
Assume that there is a database user $u$ which has read access to all views, but does not have read access to the tables.
%
The user $u$ wants to find out who is employed as a Programmer and issues the following query $Q := $ \texttt{SELECT * FROM Programmers}.
%
The mappings that are computed for the table \texttt{Programmers} before the rewriting algorithm look as follows:
\begin{itemize}
	\item $T^\bot = \lbrace \text{\texttt{ProgrammerOrClerk}, \texttt{ProgrammerOrHR}} \rbrace$
	\item $T^\top = \lbrace \text{\texttt{YoungProgrammers}, \texttt{OldProgrammers}} \rbrace$
\end{itemize}
%
Therefore the rewriting algorithm will return the following queries:
\begin{itemize}
	\item $Q^\bot$ = \texttt{SELECT * FROM ((SELECT * FROM ProgrammerOrClerk) INTERSECTION (SELECT * FROM ProgrammerOrHR)) AS Programmer}
	\item $Q^\top$ = \texttt{SELECT * FROM ((SELECT * FROM YoungProgrammers) UNION (SELECT * FROM OldProgrammers)) AS Programmer}
\end{itemize}

\subsubsection{Authorization of \texttt{SELECT} queries}

As we have seen before the both the over- and under-approximation are secure according to the current SQL standard, since all the referenced tables in those queries are readable to the user issuing the query.
%
We have further seen that the inclusions $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$ hold for the rewritten queries $Q^\top$ and $Q^\bot$.
%
The authorization algorithm for \texttt{SELECT} queries is shown in figure~\ref{alg:algorithms:auth}
%
For each \texttt{SELECT} query $Q$ the algorithm uses the rewrite function introduced above to obtain the approximations $Q^\bot$ and $Q^\top$.
%
After that the algorithm checks if the tuples returned by $Q^\bot$ and $Q^\top$ are the same, by executing the query $Q'$ = $Q^\bot$ + "\texttt{EXCEPT}" + $Q^\top$ and checking if it returns $\emptyset$.
%
If this is the case, we know that $Q^\bot \subseteq Q^\top$.
%
Further we know that $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$, which leads to the conclusion that $Q^\top = Q = Q^\bot$.
%
Since both $Q^\bot$ and $Q^\top$ are secure, we can argue that $Q$ is secure as well and authorize it.
%
\begin{algorithm}
\caption{Authorization algorithm for \texttt{SELECT} queries}
\label{alg:algorithms:auth}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{$\top$ or $\bot$}
	($Q^\bot$, $Q^\top$) = rewrite($Q$)\;
	$Q'$ = $Q^\bot$ + "\texttt{EXCEPT}" + $Q^\top$\;
	$R$ = executeQuery($Q'$)\;
	\eIf{$R$ == $\emptyset$}
		{\Return $\top$ \;}
		{\Return $\bot$ \;}
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
From the example above the authorization algorithm will execute the following query:
\begin{verbatim}
((SELECT * FROM ProgrammerOrHR) INTERSECTION
 (SELECT * FROM ProgrammerOrClerk))
 EXCEPT
((SELECT * FROM YoungProgrammer) UNION
 (SELECT * FROM OldProgrammer))
\end{verbatim}
\noindent
It is obvous that the query will return $\emptyset$, therefore the algorithm will authorize the query $Q = $ \texttt{SELECT * FROM Programmer} $\blacksquare$.