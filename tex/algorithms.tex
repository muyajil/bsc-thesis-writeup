\section{Algorithms}

As shown in~\cite{guarnieri2014optimal} query containment is a fundamental problem in database security.
%
Database access control policies specify how data can be accessed by the database users.
%
We can interpret this as assigning each database user a filter, this filter then specifies which actions the user can apply to which tuples of the database.
%
Query containment enables us to argue about the execution of queries in the presence of access control policies.
%
\remark{I have tried to just give a teaser on the problem here, in the next section we introduce it, and then we see how we can apply it. What do you think?}

\subsection{Query Containment}

The subject of query containment refers to the problem where for two queries $Q_1$ and $Q_2$ we want to answer if the tuples returned from $Q_1$ are always, i.e., in all database states, contained in the ones returned from $Q_2$.

We define the current state of a database $db$ as the sequence of commands issued to the database up to this point, further $db(t)$ returns the database state at time $t$.
%
Moreover we define the fuction $r(Q, db(t))$ which returns the bag of tuples returned from issuing $Q$ to $db(t)$.
%
A query $Q_1$ is contained in another query $Q_2$ if $r(Q_1, db(t)) \subseteq r(Q_2, db(t))$ $\forall t$.

This problem is well-known to be undecidable for relational calculus and SQL.~\cite{abiteboul1995foundations}.

\subsubsection{Query Containment Approximation}

As shown in Chapter 3, query containment is a key part in access control algorithms such as the one proposed in~\cite{guarnieri2016strong}.
Since query containment is undecidable, in general, Guarnieri et al. have developed a set of inference rules to compute sound under-approximations of query containment for relational calculus queries.
%
Here, we extend them to the SQL language.
%
Figure~\ref{figure:algorithms:grammar} describes the subset of SQL we focus on. 
%
In the following, let $T_i$ denote sequences of tables, $A_i$ denote sequences of attributes within tables, greek letters denote for boolean expressions, and $Q_i$ denote \texttt{SELECT} queries.


\begin{figure}[!ht]

\begin{tabular}{c c l}
$a$ & $:=$ & Attribute identifier \\
    & & \\
$t$ & $:=$ & Relation identifier $|$ View identifier \\ \\

$A$ & $:=$ & $a^*$ \\
    & & \\
$T$ & $:=$ &  $t^*$ \\
    & & \\
$\phi$ & $:=$ & Boolean SQL expression  \\
    & & \\
$Q$ & $:=$ & \texttt{SELECT $A$ FROM $T$ WHERE $\phi$} \\
    & $|$  & $Q$ \texttt{UNION} $Q$ \\
    & $|$  & $Q$ \texttt{INTERSECTION} $Q$ \\
    & $|$  & $Q$ \texttt{EXCEPT} $Q$ \\

\end{tabular}
\caption{Grammar of \texttt{SELECT} queries}
\label{figure:algorithms:grammar}
\end{figure}
%
Furthermore, let $w(Q)$ be the function returning the \texttt{WHERE} clause of the \texttt{SELECT} query $Q$.
%
Figure~\ref{figure:algorithms:infrules} shows our inference rules.
%
\begin{figure}[!ht]
\[
\infer[\text{ID}]
	{Q_1 \subseteq Q_1}
	{}
\qquad	
\infer[\text{AND}]
	{Q_1 \subseteq Q_2}
	{w(Q_2) = w(Q_1) \land \phi}
\qquad
\infer[\text{OR}]
	{Q_1 \subseteq Q_2}
	{w(Q_1) = w(Q_2) \lor \phi}
\]


\begin{multline*}
\infer[\text{PROJ}]
	{\texttt{SELECT}\ A_1\ \texttt{FROM}\ T_1\ \texttt{WHERE}\ \phi_1 \subseteq \texttt{SELECT}\ A_2\ \texttt{FROM}\ T_2\ \texttt{WHERE}\ \phi_2}
	{
	\texttt{SELECT}\ A_1'\ \texttt{FROM}\ T_1\ \texttt{WHERE}\ \phi_1 \subseteq \texttt{SELECT}\ A_2'\ \texttt{FROM}\ T_2\ \texttt{WHERE}\ \phi_2 \\
	\hfill A_1' = a_1^1, \ldots, a_n^2 \hfill \qquad
	\hfill A_2' = a_1^2, \ldots, a_n^2 \hfill \qquad
	\hfill 1 \leq j \leq n \hfill \\
	\hfill A_1 = a_1^1, \ldots, a_{j-1}^1, a_{j+1}^1, \ldots,  a_n^1 \hfill \qquad
	\hfill A_2 = a_1^2, \ldots, a_{j-1}^2, a_{j+1}^2, \ldots, a_n^2 \hfill 	
	}
\end{multline*}

\remark{Is $A_1'$ and $A_1$ in the wrong way here? I understand it that $A_1$ is all the attributes, and in $A_1'$ we remove the jth attribute right? Same for $A_2$}

\[
\infer[\text{INTER1}]
	{Q_1 \text{\texttt{ INTERSECTION }} Q_3 \subseteq Q_1}
	{}
\qquad
\infer[\text{INTER2}]
	{Q_3 \text{\texttt{ INTERSECTION }} Q_1 \subseteq Q_1}
	{}
\]

\[
\infer[\text{UNION1}]
	{Q_1 \subseteq Q_1 \text{\texttt{ UNION }} Q_3}
	{}
\qquad
\infer[\text{UNION2}]
	{Q_1 \subseteq Q_3 \text{\texttt{ UNION }} Q_1}
	{}
\]

\[
\infer[\text{EXCEPT}]
	{Q_1 \text{\texttt{ EXCEPT }} Q_3 \subseteq Q_1}
	{}
\qquad
\infer[\text{TRANS}]
	{Q_1 \subseteq Q_3}
	{Q_1 \subseteq Q_2 \qquad Q_2 \subseteq Q_3}
\]
\caption{Inference Rules for query containment}
\label{figure:algorithms:infrules}
\end{figure}
%
The ID-rule holds trivially.
%
In the AND-rule and OR-rule we modify the \texttt{WHERE} clause of a \texttt{SELECT} query.
%
For any of the tuples returned from a \texttt{SELECT} query the \texttt{WHERE} clause must evaluate to $\top$, therefore we filter out all tuples that do not satisfy the \texttt{WHERE} clause.
%
In the AND-rule we restrict this filter further by adding another boolean expression in conjunction.
%
In the OR-rule however, we widen the filter by adding a boolean expression in disjunction.

A requirement that one query can be contained in the other is that both queries use the same projections, i.e., the same attribute list.
%
Tuples resulting from two queries with different attribute lists are not comparable, since they can never be equal.
%
In the PROJ-rule we remove the same attribute from both attribute lists, therefore the actual tuples returned are the same, which means containment still holds.

In SQL queries return bags and not sets.
%
Bags however, support the same operations as sets, in particular they support $\cap, \cup, \setminus$.
%
SQL therefore allows to apply these operation to queries.
%
The rules INTER1 and INTER2 hold since we know that the intersection of two bags contains all elements that appear in both bags.
%
Therefore the intersection must be a subset of both initial bags.
%
The union of two bags contains all elements that appear in at least one of the intial bags, therefore we can follow that both inital bags are contained in the union.
%
The rule EXCEPT holds by the definition of subtracting multisets.

Lastly the rule TRANS holds by the definition of containment.

\FloatBarrier
\subsection{Checking security of \texttt{SELECT} queries}

As seen in Chapter 2 \texttt{SELECT} queries are trivially authorized by the access control mechanism if the user that issues the query has read privileges on all the referenced tables.
%
However this mechanism is too restrictive for implementing a powerful mechanism such as the one presented in~\cite{guarnieri2016strong}.
%
The authors of~\cite{guarnieri2016strong} have developed an algorithm that checks the security of queries, which relies on query containment and query rewriting. 

For each table or view $T$, we denote by $T^\top$ (respectively $T^\bot$) the set of tables or views that are contained in (respectively contain) $T$.
%
This set is computed using the query containment rules introduced in Section 5.1.1.
%

Here we use these sets to provide the same rewriting as in~\cite{guarnieri2016strong}, but for SQL.
%
For each query $Q$ the rewriting algorithm produces a secure over-approximation $Q^\bot$ and under-approximation $Q^\top$ of the query.

\subsubsection{Rewriting Algorithm}
%
Our rewriting algorithm is shown in Algorithm~\ref{alg:algorithms:rewrite}.
%
The algorithm returns the two queries $Q^\bot$ and $Q^\top$.
%
The query $Q^\bot$ is built by replacing each referenced table $T$ by the intersection of all the tables $\tau \in T^\bot$ that the user is authorized to read.
%
$Q^\top$ is built analogously with unions of all the tables $\tau \in T^\top$.
%
We further define the helper function \emph{$S$.card()}, which returns the cardinality of the set $S$.

Since we only consider tables or views from $T^\top$ and $T^\bot$, which, according to the access control policy, are readable to the user, it follows that any query constructed by the rewriting algorithm is secure.
%
Therefore it is trivial that both queries $Q^\bot$ and $Q^\top$ are secure, since all the tables referenced within are readable to the user issuing the query.

We can further argue that $Q^\top \subseteq Q \subseteq Q^\bot$ since the rewriting algorithm approximates the results of $Q$ from below and above. 
%
\begin{algorithm}
\caption{Rewriting Algorithm for SQL queries}
\label{alg:algorithms:rewrite}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{Rewritten queries $Q^\top$, $Q^\bot$}
	$Q^\bot$ = $Q$\;
	$Q^\top$ = $Q$\;
	\ForEach{table $T$ referenced in $Q$}{
		$T'$ = "("\;
		$T''$ = "("\;
		numBot = $T^\bot.card()$\;
		numTop = $T^\top.card()$\;
		\ForEach{table $\tau$ in $T^\bot$}{
			numBot--\;
			\If{$u$ is authorized to read $\tau$}
				{\eIf{numBot > 0}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$) INTERSECTION}"\;}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
     	
		\ForEach{table $\tau$ in $T^\top$}{
		    numTop--\;
			\If{$u$ is authorized to read $\tau$}
				{\eIf{numTop > 0}
					{$T''$ += "\texttt{(SELECT * FROM $\tau$) UNION}"\;}
					{$T''$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
		$T'$ += "\texttt{) AS $T$}"\;
		$T''$ += "\texttt{) AS $T$}"\;
		Replace $T$ with $T'$ in $Q^\bot$\;
     	Replace $T$ with $T''$ in $Q^\top$\;
     }

     \Return ($Q^\bot$, $Q^\top$)\;
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
Recall the example given in Chapter 2:
\\
Consider a database with tables \texttt{Programmers}, \texttt{Clerks}, and \texttt{HR}, containing the information of employees of the respective departments.
%
Further the database contains the following views:
\begin{itemize}
	\item \texttt{OldProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age > 40}
	\item \texttt{YoungProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age <= 40}
	\item \texttt{ProgrammerOrClerk} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM Clerks)}
	\item \texttt{ProgrammerOrHR} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM HR)}
\end{itemize}
%
Assume that there is a database user $u$ which has read access to all views, but does not have read access to the tables.
%
The user $u$ wants to find out who is employed as a Programmer and issues the following query $Q := $ \texttt{SELECT * FROM Programmers}.
%
The mappings that are computed for the table \texttt{Programmers} before the rewriting algorithm look as follows:
\begin{itemize}
	\item $T^\bot = \lbrace \text{\texttt{ProgrammerOrClerk}, \texttt{ProgrammerOrHR}} \rbrace$
	\item $T^\top = \lbrace \text{\texttt{YoungProgrammers}, \texttt{OldProgrammers}} \rbrace$
\end{itemize}
%
Therefore the rewriting algorithm will return the following queries:
\begin{itemize}
	\item $Q^\bot$ = \texttt{SELECT * FROM ((SELECT * FROM ProgrammerOrClerk) INTERSECTION (SELECT * FROM ProgrammerOrHR)) AS Programmer}
	\item $Q^\top$ = \texttt{SELECT * FROM ((SELECT * FROM YoungProgrammers) UNION (SELECT * FROM OldProgrammers)) AS Programmer}
\end{itemize}

\subsubsection{Authorization of \texttt{SELECT} queries}

As we have seen before the both the over- and under-approximation are secure according to the current SQL standard, since all the referenced tables in those queries are readable to the user issuing the query.
%
We have further seen that the inclusions $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$ hold for the rewritten queries $Q^\top$ and $Q^\bot$.
%
The authorization algorithm for \texttt{SELECT} queries is shown in figure~\ref{alg:algorithms:auth}
%
For each \texttt{SELECT} query $Q$ the algorithm uses the rewrite function introduced above to obtain the approximations $Q^\bot$ and $Q^\top$.
%
After that the algorithm checks if the tuples returned by $Q^\bot$ and $Q^\top$ are the same, by executing the query  $Q^\bot$ \texttt{EXCEPT} $Q^\top$ and checking if it returns $\emptyset$.
%
If this is the case, we know that $Q^\bot \subseteq Q^\top$.
%
Further we know that $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$, which leads to the conclusion that $Q^\top = Q = Q^\bot$.
%
Since both $Q^\bot$ and $Q^\top$ are secure, we can argue that $Q$ is secure as well and authorize it.
%
\begin{algorithm}
\caption{Authorization algorithm for \texttt{SELECT} queries}
\label{alg:algorithms:auth}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{$\top$ or $\bot$}
	($Q^\bot$, $Q^\top$) = rewrite($Q$)\;
	$Q'$ = $Q^\bot$ + "\texttt{EXCEPT}" + $Q^\top$\;
	$R$ = executeQuery($Q'$)\;
	\eIf{$R$ == $\emptyset$}
		{\Return $\top$ \;}
		{\Return $\bot$ \;}
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
From the example above the authorization algorithm will execute the following query:
\begin{verbatim}
((SELECT * FROM ProgrammerOrHR) INTERSECTION
 (SELECT * FROM ProgrammerOrClerk))
 EXCEPT
((SELECT * FROM YoungProgrammer) UNION
 (SELECT * FROM OldProgrammer))
\end{verbatim}
\noindent
It is obvous that the query will return $\emptyset$, therefore the algorithm will authorize the query $Q = $ \texttt{SELECT * FROM Programmer} $\blacksquare$.

\paragraph{Extension to the Truman model}

The algorithms devised in this chapter are constructed under the \emph{Non-truman model}.
%
Identified in~\citep{rizvi2004extending} it specifies an access control mechanism as a component which decides if a query is optimized or not, and therefore returns $\bot$ or $\top$.
%
The current implementations of these mechanisms either interrupt the execution of the query and notify the user if a query was not authorized or do not interrupt the execution of the query if the query was authorized.
%
The Non-truman model is the most used model in database access control mechanisms.
%
The \emph{Truman model} however, uses access control mechanisms with another approach, namely the access control internally executes the query, and only returns the tuples, which are readable for the user according to the access control policy.
%
The user issuing a query will not notice if the query he issued is not authorized for him.
%
Our algorithm is extensible to, and even would be better suited for the Truman model.
%
We under-approximate the tuples resulting from a query during the algorithm that returns the access control decision, and we further know that the under-approximation is secure with respect to the access control policy.
%
Therefore it is secure to return the under-approximation to the user.
%
Our implementation contains a subset of the introduced inference rules for containment, implementing all of them would result in a better under-approximation.
%
Algorithm~\ref{alg:algorithms:authtruman} shows how our algorithm can be extended to the Truman model.
%
\begin{algorithm}
\caption{Authorization algorithm for \texttt{SELECT} queries in the Truman model}
\label{alg:algorithms:authtruman}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{$R$, the tuples returned from the query that are readable to the user}
	($Q^\bot$, $Q^\top$) = rewrite($Q$)\;
	$R$ = executeQuery($Q^\top$)\;
	\Return $R$
\end{algorithm}