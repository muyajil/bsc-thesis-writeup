\section{Algorithms}

\remark{Here you should give some intuition why we're dealing with query containment for security}

\subsection{Query Containment}

\remark{Here, First give the intuition, then formalize the problem, then give results.}

The subject of query containment refers to the problem where for two queries $Q_1$ and $Q_2$ we want to answer if the tuples returned from $Q_1$ are always, i.e., in all database states, contained in the ones returned from $Q_2$.
%
This problem is well-known to be undecidable for relational calculus and SQL.~\cite{abiteboul1995foundations}.
%
\remark{Discuss its use in databases.}

\subsubsection{Query Containment Approximation}

As shown in Chapter 3, query containment is a key part in access control algorithms such as the one proposed in~\cite{guarnieri2016strong}.
Since query containment is undecidable, in general, Guarnieri et al. have developed a rule set that produces sound under-approximations of query containment.
%
The rules were developed for the relational calculus.
%
Here, we extend them to the SQL language.
%
Let $T_i$ denote sequences of tables, $A_i$ sequences of attributes within tables, greek letters stand for boolean expressions, and $Q_i$ \texttt{SELECT} queries as shown in figure~\ref{figure:algorithms:grammar}.


\begin{figure}[!ht]

\begin{tabular}{c c l}
$A$ & $:=$ & Attributes \\
    & & \\
$T$ & $:=$ & Relation $|$ View \\
    & & \\
$\phi$ & $:=$ & Boolean expression over attributes $|$ $\top$ \\
    & & \\
$Q$ & $:=$ & \texttt{SELECT $A$ FROM $T$ WHERE $\phi$} \\
    & $|$  & $Q$ \texttt{UNION} $Q$ \\
    & $|$  & $Q$ \texttt{INTERSECTION} $Q$ \\
    & $|$  & $Q$ \texttt{EXCEPT} $Q$ \\

\end{tabular}

\caption{Grammar of \texttt{SELECT} queries}
\label{figure:algorithms:grammar}
\end{figure}
%
Further we define $w(Q)$ as a function which returns the \texttt{WHERE} clause of the \texttt{SELECT} query $Q$.
%
Figure~\ref{figure:algorithms:infrules} shows our inference rules.
%
\begin{figure}[!ht]
\[
\infer[\text{ID}]
	{Q_1 \subseteq Q_1}
	{}
\qquad	
\infer[\text{AND}]
	{Q_1 \subseteq Q_2}
	{w(Q_2) = w(Q_1) \land \phi}
\qquad
\infer[\text{OR}]
	{Q_1 \subseteq Q_2}
	{w(Q_1) = w(Q_2) \lor \phi}
\]

\[
\infer[\text{PROJ1}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad A_1 \setminus A_1' = A_2 \setminus A_2'}
\qquad
\infer[\text{PROJ2}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad T_1 \setminus T_1' = T_2 \setminus T_2'}
\]
\remark{$A_1$, $A_1'$, $A_2$, and $A_2'$ (same for the tables) are free variables and its unclear how they are related to the queries.}

\[
\infer[\text{PROJ3}]
	{Q_1' \subseteq Q_2'}
	{Q_1 \subseteq Q_2 \qquad A_1 \setminus A_1' = A_2 \setminus A_2' \qquad T_1 \setminus T_1' = T_2 \setminus T_2'}
\]

\remark{Doesn't this just follow from the previous two rules and transitivity?}

\[
\infer[\text{INTER1}]
	{Q_1 \text{\texttt{ INTERSECTION }} Q_3 \subseteq Q_1}
	{}
\qquad
\infer[\text{INTER2}]
	{Q_3 \text{\texttt{ INTERSECTION }} Q_1 \subseteq Q_1}
	{}
\]

\[
\infer[\text{UNION1}]
	{Q_1 \subseteq Q_1 \text{\texttt{ UNION }} Q_3}
	{}
\qquad
\infer[\text{UNION2}]
	{Q_1 \subseteq Q_3 \text{\texttt{ UNION }} Q_1}
	{}
\]

\[
\infer[\text{EXCEPT}]
	{Q_1 \text{\texttt{ EXCEPT }} Q_3 \subseteq Q_1}
	{}
\qquad
\infer[\text{TRANS}]
	{Q_1 \subseteq Q_3}
	{Q_1 \subseteq Q_2 \qquad Q_2 \subseteq Q_3}
\]
\caption{Inference Rules for query containment}
\label{figure:algorithms:infrules}
\end{figure}

\remark{Explain each ``family'' of rules. Give some intuition, and explain why they are sound.
%
I'd avoid saying ``holds trivially'' too much, as it downplays your contribution.}

The ID-rule holds trivially.
%
In the AND-rule we restrict the resulting bag further by adding a boolean expression in conjunction. 
%
Therefore the rule holds.
%
The OR-rule holds by the same argumentation, namely we extend the resulting bag, by adding a boolean expression in disjunction,  which increases the number of tuples satisfying the \texttt{WHERE} clause. \remark{This part is unclear.}
%
The PROJ1-rule is valid since we project out the same set of attributes. Therefore the actual rows returned from the table are the same, with less attributes.
%
\remark{I am not perfectly sure about the PROJ rules. This is the intuition, but make it clearer.}
%
The PROJ2-rule holds since we reduce the multiset of tuples from which we select by the same tuples in both queries.
%
By combining PROJ1 and PROJ2 we get the rule PROJ3.
%
The rules INTER1 and INTER2 hold trivially, by the definition of intersecting two multisets.
%
The same argumentation holds for the rules UNION1 and UNION2, which rely on the definition of unifying multisets.
%
The rule EXCEPT holds by the definition of subtracting multisets.
%
Lastly the rule TRANS holds by the definition of containment.

\FloatBarrier
\subsection{Checking security of \texttt{SELECT} queries}

As seen in Chapter 2 \texttt{SELECT} queries are trivially authorized \remark{authorized by the SQL query?} if the user that issues the query has read privileges on all the referenced tables.
%
However this mechanism is too restrictive for implementing a powerful mechanism such as the one presented in~\cite{guarnieri2016strong}.
%
The authors of~\cite{guarnieri2016strong} have developed an algorithm that checks the security of queries, which relies on query containment and query rewriting. 
%
For each query $Q$ the rewriting algorithm produces a secure over-approximation $Q^\bot$ and under-approximation $Q^\top$ with respect to query containment, using the rule set introduced above. \remark{This part is unclear. The under and over-approximations are not computed using the rules.}
%
\remark{This part is unclear. Why don't you just say something like ``For each table or view $O$, we denote by $O^\top$ (respectively $O^\bot$) the set ... . This set is computed using the query containment rules introduced in Section XX''} 
%
The extended rule set is used to create two mappings within the database.
%
We map all tables or views $T$ to the set $T^\bot$, which contains all tables or views that contain $T$ based on the above inference rules.
%
In the same way we map each table or view $T$ to the set $T^\top$, which contain all tables or views that are contained by $T$.
%
Here we use these mappings to provide the same rewriting as in~\cite{guarnieri2016strong}, but for SQL.

\subsubsection{Rewriting Algorithm}
%
Our rewriting algorithm is shown in Algorithm~\ref{alg:algorithms:rewrite}. % shows a pseudo code of the implementation.
%
The algorithm returns the two queries $Q^\bot$ and $Q^\top$.
%
The query $Q^\bot$ is built by replacing each referenced table $T$ by the intersection of all the tables $\tau \in T^\bot$ that the user is authorized to read.
%
$Q^\top$ is built analogously with unions of all the tables $\tau \in T^\top$.
%
We further define the helper function \emph{$S$.hasNext()}, which returns false if the table $\tau$ is the last one in the set $S$ and true otherwise. \remark{hasNext does not make any sense for a set (no order)}



\remark{Explain this part a bit more.}
%
Therefore it is trivial that both queries $Q^\bot$ and $Q^\top$ are secure, since all the tables referenced within are readable to the user issuing the query.
%
Using the inference rules we can further show that for any query $Q$ it holds that $Q^\top \subseteq Q \subseteq Q^\bot$.
%
\remark{I'm pretty sure you cannot prove this using our rules.}

%
\begin{algorithm}
\caption{Rewriting Algorithm for SQL queries}
\label{alg:algorithms:rewrite}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{Rewritten queries $Q^\top$, $Q^\bot$}
	$Q^\bot$ = $Q$\;
	$Q^\top$ = $Q$\;
	\ForEach{table $T$ referenced in $Q$}{
		$T'$ = "("\;
		$T''$ = "("\;
		\ForEach{table $\tau$ in $T^\bot$}{
			\If{$u$ is authorized to read $\tau$}
				{\eIf{$T^\bot$.hasNext()}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$) INTERSECTION}"\;}
					{$T'$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
     	
		\ForEach{table $\tau$ in $T^\top$}{
			\If{$u$ is authorized to read $\tau$}
				{\eIf{$T^\top$.hasNext()}
					{$T''$ += "\texttt{(SELECT * FROM $\tau$) UNION}"\;}
					{$T''$ += "\texttt{(SELECT * FROM $\tau$)}"\;}
				}
		}
		$T'$ += "\texttt{) AS $T$}"\;
		$T''$ += "\texttt{) AS $T$}"\;
		Replace $T$ with $T'$ in $Q^\bot$\;
     	Replace $T$ with $T''$ in $Q^\top$\;
     }

     \Return ($Q^\bot$, $Q^\top$)\;
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
Recall the example given in Chapter 2:
\\
Consider a database with tables \texttt{Programmers}, \texttt{Clerks}, and \texttt{HR}, containing the information of employees of the respective departments.
%
Further the database contains the following views:
\begin{itemize}
	\item \texttt{OldProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age > 40}
	\item \texttt{YoungProgrammers} defined as \\ \texttt{SELECT * FROM Programmers WHERE Age <= 40}
	\item \texttt{ProgrammerOrClerk} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM Clerks)}
	\item \texttt{ProgrammerOrHR} defined as \\ \texttt{(SELECT * FROM Programmers) UNION (SELECT * FROM HR)}
\end{itemize}
%
Assume that there is a database user $u$ which has read access to all views, but does not have read access to the tables.
%
The user $u$ wants to find out who is employed as a Programmer and issues the following query $Q := $ \texttt{SELECT * FROM Programmers}.
%
The mappings that are computed for the table \texttt{Programmers} before the rewriting algorithm look as follows:
\begin{itemize}
	\item $T^\bot = \lbrace \text{\texttt{ProgrammerOrClerk}, \texttt{ProgrammerOrHR}} \rbrace$
	\item $T^\top = \lbrace \text{\texttt{YoungProgrammers}, \texttt{OldProgrammers}} \rbrace$
\end{itemize}
%
Therefore the rewriting algorithm will return the following queries:
\begin{itemize}
	\item $Q^\bot$ = \texttt{SELECT * FROM ((SELECT * FROM ProgrammerOrClerk) INTERSECTION (SELECT * FROM ProgrammerOrHR)) AS Programmer}
	\item $Q^\top$ = \texttt{SELECT * FROM ((SELECT * FROM YoungProgrammers) UNION (SELECT * FROM OldProgrammers)) AS Programmer}
\end{itemize}

\subsubsection{Authorization of \texttt{SELECT} queries}

As we have seen before the both the over- and under-approximation are secure according to the current SQL standard, since all the referenced tables in those queries are readable to the user issuing the query.
%
We have further seen that the inclusions $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$ hold for the rewritten queries $Q^\top$ and $Q^\bot$.
%
The authorization algorithm for \texttt{SELECT} queries is shown in figure~\ref{alg:algorithms:auth}
%
For each \texttt{SELECT} query $Q$ the algorithm uses the rewrite function introduced above to obtain the approximations $Q^\bot$ and $Q^\top$.
%
After that the algorithm checks if the tuples returned by $Q^\bot$ and $Q^\top$ are the same, by executing the query  $Q^\bot$ \texttt{EXCEPT} $Q^\top$ and checking if it returns $\emptyset$.
%
If this is the case, we know that $Q^\bot \subseteq Q^\top$.
%
Further we know that $Q^\top \subseteq Q$ and $Q \subseteq Q^\bot$, which leads to the conclusion that $Q^\top = Q = Q^\bot$.
%
Since both $Q^\bot$ and $Q^\top$ are secure, we can argue that $Q$ is secure as well and authorize it.
%
\begin{algorithm}
\caption{Authorization algorithm for \texttt{SELECT} queries}
\label{alg:algorithms:auth}
	\SetAlgoLined
	\KwData{Query $Q$, user $u$}
	\KwResult{$\top$ or $\bot$}
	($Q^\bot$, $Q^\top$) = rewrite($Q$)\;
	$Q'$ = $Q^\bot$ + "\texttt{EXCEPT}" + $Q^\top$\;
	$R$ = executeQuery($Q'$)\;
	\eIf{$R$ == $\emptyset$}
		{\Return $\top$ \;}
		{\Return $\bot$ \;}
\end{algorithm}

\smallskip
\noindent
{\bf Example:}
From the example above the authorization algorithm will execute the following query:
\begin{verbatim}
((SELECT * FROM ProgrammerOrHR) INTERSECTION
 (SELECT * FROM ProgrammerOrClerk))
 EXCEPT
((SELECT * FROM YoungProgrammer) UNION
 (SELECT * FROM OldProgrammer))
\end{verbatim}
\noindent
It is obvous that the query will return $\emptyset$, therefore the algorithm will authorize the query $Q = $ \texttt{SELECT * FROM Programmer} $\blacksquare$.