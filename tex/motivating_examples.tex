\section{Motivating Examples}

We show here how users can exploit advanced features of DBMSs to attack database confidentiality
%
The following attacks were first presented in~\cite{guarnieri2016strong}
%
In these attacks, the attacker manages to learn sensitive information from the database, that according to the security policy, should not be disclosed to the attacker.
%
Guarnieri et al. have mounted these attacks manually against several widely used DBMS with shocking results: No existing access control mechanism is able to fully prevent these attacks.

\subsection{Confidentiality Attacks}

In the following we will present confidentiality attacks. 
%
We will use \texttt{SELECT} and \texttt{INSERT} commands in combination with triggers and integrity constraints to infer classified information.
%
According to~\cite{guarnieri2016strong} integrity constraints are invariants that must be satisfied for a database state to be considered \emph{valid}.
%
\emph{Integrity constraint violations} arise when the execution of an SQL command leads the database from a valid state into an invalid one.
%
\begin{attack}
{\bf Table updates and integrity constraints.}
%
Consider a database with two tables $P$ and $S$. 
%
Suppose the primary key for both tables is the user's identifier.
%
Furthermore the set of user identifiers in $S$ is contained in the set of user identifiers in $P$, i.e., there is a foreign key from $S$ to $P$.
%
The attacker is user $u$, whose goal is to learn whether \texttt{Bob} is in $S$.
%
The access control policy is as follows: $u$ can read from $P$ and insert tuples into $S$.

The attacker can learn whether \texttt{Bob} is in $S$ as follows:
\begin{enumerate}
	\item He reads $P$ and learns \texttt{Bob}'s identifier.
	\item He issues an \texttt{INSERT} statement into $S$ using \texttt{Bob}'s id.
	\item If \texttt{Bob} is already in $S$, then $u$ gets an error message about the primary key's violation. Alternatively there is no violation and $u$ learns that \texttt{Bob} is not in $S$.
\end{enumerate}
\end{attack}
%
In the next attack the attacker learns sensitive information by exploiting triggers.
%
The trigger is executed with owner's privileges, meaning it is executed with the same privileges as the user, which has created the trigger.

\begin{attack}
{\bf Triggers with owner's privileges.}
%
Consider a database with tables $P$, $T$, and $N$.
%
The attacker is user $u$, who wishes to learn whether $v$ is in $T$.
%
The policy is as follows:
%
$u$ is not authorized to read table $T$, and he can read and modify tables $P$ and $N$.
%
Moreover, the following trigger has been defined by the administrator:
%
\begin{verbatim}
CREATE TRIGGER t on P AFTER INSERT FOR EACH ROW
	IF EXISTS(SELECT * FROM T where id = new.id)
		INSERT new.id INTO N;
\end{verbatim}
%
The attack is as follows:
%
\begin{enumerate}
	\item $u$ deletes $v$ from $N$.
	\item $u$ issues the command:
		\begin{verbatim}
		INSERT INTO P VALUES(v).
		\end{verbatim}
	\item $u$ checks the table $N$. If it contains $v$'s id, then $v$ is in $T$. Otherwise $v$ is not in $T$.
\end{enumerate}
%
\end{attack}
%
This attack leverages the fact that the trigger conditionally modifies the database.

\remark{Should I say something more here or just leave it at that?}

