\section{Background}

Here, we introduce the SQL access control model and outline how it is implemented in PostgreSQL.
%
The conclusions made in the following paragraphs are backed by an analysis of the  PostgreSQL's code, since a proper documentation of the internals is missing.

\subsection{SQL access control model}

%In SQL access control model database users have privileges.
The SQL standard defines a number of privileges, where each privilege represents an operation that can be done in the database, such as creating tables, creating triggers, or updating tables.

Privileges can be assigned either on the database or on a \emph{database object}.
%
A database object refers to an internal structure of the database, such as a table, a trigger, or a view. 
%
When a user creates a database object, he is the owner of the object and therefore intrinsically receives all privileges on this object, including the privilege to delegate those to other users.
%
The privileges can be assigned to users using \texttt{GRANT} commands and revoked using \texttt{REVOKE} commands.
%
Note that the execution of  \texttt{GRANT} and \texttt{REVOKE} is regulated as well by the access control policy. 
%
A \texttt{GRANT} or \texttt{REVOKE} query on some database object is authorized if the user issuing the query is the database administrator, the owner of the database object, or if the user holds a \emph{grant option} on the privilege he is trying to assing or revoke.
%
A grant option can be assigned to a user together with a privilege.
%
The grant option gives the user the ability to delegate a privilege further.

In PostgreSQL, the SQL access control model is implemented as follows.
%
To simplify the creation of access control policies PostgreSQL supports the use of \emph{database roles}.
%
A database role can be either a single database user, a group of database users, or public. 
%
Groups of database users are used to manage privileges in bulk for users that enjoy similar privileges.
%
If a user was not assigned any specific privileges on a database objects either through group membership or directly, he automatically has all the privileges that are assigned to public.
%
Privileges are encoded using \emph{access control lists} (ACLs).
%
ACLs consist of several bitmasks.
%
Each bitmask represents the privileges assinged to a database role, further each bit within the mask represents one privilege.
%

\subsection{Implementation in PostgreSQL}

The implementation in PostgreSQL follows the SQL standard to large extents. 
%
There are however subtle differences between the former and the latter.
%
\remark{add a better example than triggers}

When users submit queries to the database system, depending on the type of the query, an internal function is called, which among other things, retrieves the ACL for objects that are referenced in the query and checks the privileges.
%
Then the function will, according to the retrieved ACL either authorize the query or not.

\subsection{Algorithm proposed by Guarnieri et al.}

As mentioned in Chapter 1 Guarnieri et al. have devised a new access control mechanism.
%
One key component of this mechanism is deciding if boolean queries in the relational calculus are secure with respect to the access control policy.
%
For this they devised rules on how to compute under-approximations of query containment.
%
They used these approximations to generate secure under- and over-approximations of queries using a rewriting mechanism.
%
They further devised a function \emph{secure} which uses the rewriting mechanism to decide the authorization of queries.
%
These findings are extended to support SQL in chapter 5.

\remark{This does not add much to what we said in the introduction. I'd give some more details about the algorithm.
%
The idea is that you want to extend the algorithm from RC to SQL.
%
So, first explain how the algorithm work (and the main components) for RC.
%
Afterwards, you can just say that you want to extend it to SQL, and you explain, component by component, how you achieved it.}