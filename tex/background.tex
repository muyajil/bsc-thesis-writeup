\section{Background}

In this Chapter we introduce the SQL access control model and outline how it is implemented in PostgreSQL.
%
The conclusions made in the following paragraphs are backed by an analysis of the backend code of PostgreSQL, since a proper documentation of the internals is missing.

\subsection{SQL access control model}

In the SQL access control model database users have privileges. 
%
Each privilege represents an operation that can be done in the database, such as, creating tables, creating triggers, update tables etc.
%
The privileges can be assigned using \texttt{GRANT} and revoked using \texttt{REVOKE}.
%
However the user issuing these queries, must have the privilege to delegate privileges to other users.
%
At the beginning of the execution of a DBMS this is the database administrator.
%
Privileges can be assigned either to the database or to a \emph{database object}.
%
A database object refers to an internal structure of the database, such as tables, triggers, views etc.
%
Further, privileges are encoded using \emph{access control lists} (ACLs). 
%
Each ACL specifies the privileges for each \emph{database role}.
%
A database role can be one of public, group of database users, or a single database user.
%
Groups of database users are used to manage privileges in bulk for users that enjoy similar privileges.
%
When a user creates a database object, he is the owner of the object and therefore intrinsically receives all privileges on this object, including the privilege to delegate those to other users.

\subsection{Implementation in PostgreSQL}

The implementation in PostgreSQL follows the SQL standard to large extents. 
%
There are however subtle differences between the former and the latter.
%
For instance in the SQL standard triggers are defined as separate SQL queries, which are executed in response to regular queries issued by users.
%
PostgreSQL however offers the possibility to execute, among others, C functions as triggers.
%
This requires a different implementation.
%
Therefore in PostgreSQL triggers are actually just references to functions, in more detail, a trigger consists of a condition and a function.
%
If during the execution of a user submitted query the condition is satisfied, the function is executed.
%
Therefore the access control mechanism needs to handle the execution of functions differently.
%
If a user creates a trigger in the SQL standard he only needs the privilege to create triggers.
%
In PostgreSQL however the user needs the privilege to create triggers and the execution privilege on the function he wants to execute with the trigger.
%
If however the execution privilege on the function is revoked, the trigger stays intact.

When users submit queries to the database system, depending on the type of the query, an internal function is calles, which among other things, retrieves the ACL for objects that are referenced in the query and checks the privileges.
%
Then the function will, according to the retrieved ACL either authorize the query or not.

\subsection{Algorithm proposed by Guarnieri et al.}

As mentioned in Chapter 1 Guarnieri et al. have devised a new access control mechanism.
%
One key component of this mechanism is deciding if boolean queries in the relational calculus are secure with respect to the access control policy.
%
\remark{how deep should I go here? Should I try to explain security of judgements, or keep an overview and talk about resulting tuples from queries?}
%
