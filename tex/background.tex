\section{Background}

In this section it is shown why the current access control mechanisms are flawed by contrasting the current access control mechanism in PostgreSQL with the new access control mechanism based on~\cite{guarnieri2016strong}.
%
\subsection{Current access control mechanism in PostgreSQL}
%
The access control mechanism used in PostgreSQL is to large extent an implementation of the access control model defined by the SQL standard.
%
This standard makes the assumption that information can only be leaked through \texttt{SELECT} queries issued to the DBMS.
%
The conclusions made in the following paragraphs are backed by an analysis of the backend code of PostgreSQL, since a proper documentation of the internals is missing.

The administrator has to define an access control policy for the database.
%
This policy defines how users can interact with the system.
%
A database object can refer to any structure within a database: tables, views, triggers, functions etc.
%
For each object the administrator has to define \emph{access control lists} (ACLs) for each database role.
%
The administrator can define an ACL for the public, a group or a user. 
%
These ACLs then define the privileges to a database object for a database role.
%
The privileges among others include creation of tables, views or triggers in the database or reading, altering or deleting of tuples from tables or views.
%
These privileges can be modified using \texttt{GRANT} or \texttt{REVOKE} commands, whereas the execution of those is also based on the ACLs.
%
The possible privileges include insert, update, select, create, execute etc.\footnote{\url{http://www.postgresql.org/docs/9.5/static/sql-grant.html}}
%
Depending on the object different privileges are applicable. For example the execution privilege is only applicable to functions and triggers, whereas the insert privilege is only applicable to tables or views.
%
When issuing a query to the database, depending on the query, a function is executed which, among other things, retrieves the ACL for the objects referenced in the query and checks if the required privileges are available for the user issuing the command.
%
When deciding if a \texttt{SELECT} query is authorized, we can distinguish two cases: 
%
In the first case the user issuing the query has read privileges on all the relations in the \texttt{FROM} clause of the query, then security is trivial and we can allow the query. 
%
In the second case the user does not have read privileges on all the tables in the \texttt{FROM} clause of the query. 
%
The current access control mechanism will not authorize this query.
%
The access control mechanism implemented in PostgreSQL does not take into account other aspects of the database system, i.e., in the case of an \texttt{INSERT} query there is no check if the execution of triggers might reveal information to an attacker.
%
The attacks in the previous section succeed because of this behaviour.
%
\remark{What should I add here? I could explain the process that happens for a \texttt{SELECT} in detail here, it will sound complicated but boil down to comparing bits in the ACL, what do you think?}
%
\subsection{New access control mechanism}
%
The approach taken in the access control mechanism based on the model proposed in~\cite{guarnieri2016strong} is different.
%
The basis for creating an access control policy are still ACLs, but the basis for deciding if a command is allowed to be executed is the resulting behaviour of the database system.

\remark{Can we talk about how to continue here? I think this is a bit unclear to me and to the reader. As you mentioned we need a good example here that can explain the situation}